<?xml version="1.0" encoding="iso-8859-1"?>
<!-- Processing Instruction generated by Amaya; the stylesheet is
     available on the W3C site at http://www.w3.org/Math/XSL/pmathml.xsl -->
<?xml-stylesheet type="text/xsl" href="pmathml.xsl"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN"
      "http://www.w3.org/TR/MathML2/dtd/xhtml-math11-f.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Primer - Processing Semantic Web data using N3</title>
  <link href="/People/Berners-Lee/general.css" rel="stylesheet"
  type="text/css" />
</head>

<body xml:lang="en">
<p><a href="/">W3C</a> | <a href="/2000/01/sw/Overview.html">Semantic Web</a>
| <a href="Overview.html">SWAP</a></p>
<br />
<br />


<h1>Primer: Rules and Formulae</h1>

<p>We are going to learn how to express rules in N3, which will allow us to
do all kinds of things. A simple rule might say something like (in a
mechanical vocabulry, say) "If one this includes another, then the second is
a part of the first", or</p>
<pre>{ :thermostat :temp :high } log:implies { :heating :power "0" } .</pre>

<p>The curly brackets here enclose a set of statements. Until this point, all
statements in each file have been effectively in one bucket. They are all
generated when the file is parsed, and stored in a store on an equal footing.
In a rule, however, we need to talk about hypothetical statements:
<em>If</em> this <em>were</em> the case <em>then</em> that <em>would</em> be
the case. The statements within the brackets are not asserted like the other
ones in the file. In the case above, the file does not say that the
thermostat temperature is high. It just says that the left-hand formula
implies the right-hand formula.</p>

<p>You see that, apart from the fact that the subject and object of the
statement are formulae, the line above is just a single statement.
log:implies is a special predicate which links formulae. The statement is a
fact. Rules are in general facts, and on the semantic web they may or not be
used by various programs at various times to figure things out.</p>

<p>The curly brackets are important. They do take us out of the things we can
represent using the current RDF/XML OWL specifications. ((Formulae are
(2003/2) a longer-term issue for the RDF Core group). Cwm will in most cases
serialize formulae using an XML sysntax which is not standard.</p>

<p></p>

<h2>Variables</h2>

<p>In fact, formulae in N3 are more than just sets of statements. They also
allow declarations of variables. A variable is like just a symbol (such as
<code>:x</code> or <code>var:Y</code>) except it is used to stand for other
symbols. There are two types. A "<code>forAll</code>" or <dfn>universal</dfn>
variable, declared like this,</p>
<pre>this log:forAll :x.
{ :thermostat :temp :x } log:implies { :cooling :power :x } .</pre>

<p>means that all this information is true even if the symbol ":x" is
replaced consistently by something else. This is of course what you want for
a rule which implies something generally about anything. The
<code>"this"</code> indicates the scope of the variable - it in fact stands
for the formula in which it is, in this case the outermost formula of the
document. In most cases for simple rules, the variables are quantified in the
scope of the document, but when things get nested, it is wise to think about
what you mean. We don't deal with it in detail here. Mathematically, the</p>

<p><math xmlns="http://www.w3.org/1998/Math/MathML">
  <mo>&ForAll;</mo>
  <mi>x</mi>
  <mo>(</mo>
  <mi>temp</mi>
  <mo>(</mo>
  <mi>thermostat</mi>
  <mo>,</mo>
  <mi>x</mi>
  <mo>)</mo>
  <mo>&DoubleRightArrow;</mo>
  <mi>power</mi>
  <mo>(</mo>
  <mi>cooling</mi>
  <mo>,</mo>
  <mi>x</mi>
  <mo>)</mo>
  <mo>)</mo>
</math>
</p>

<p>A formula can also have "<code>forSome</code>", or <dfn>existential</dfn>,
variables. They are declared as in</p>
<pre>this log:forSome :a.
:Joe :home :a.
:a  :phone "555-1212".</pre>

<p>This means that there is something which is Joe's home and has the given
phone number. We've been doing this all along, though, surely, with blank
nodes. Indeed - most times that an existential variable is used it is
actually implicit in the [bracket] syntax.</p>
<pre>:Joe :home [ :phone "555-1212" ].</pre>

<p></p>

<p>Each pair of square brackets actully stands for an unnamed existential
variable. Cwm will generally use square brackets on output when it can - if
there are loops then one has to use explict variables.</p>
<pre>this log:forSome :a.
:Joe :home :a.
:a   :owner :Joe.
:a  :phone "555-1212".</pre>

<p></p>

<h2><a id="Variables1">Variables with ? and _:</a></h2>

<p>So far we have introduce variables for rules using <em>log:forAll</em>. We
have introduced existential variables (blank nodes) with
<code>log:forSome</code>. These are both special pseudoProperies which are
really special langauge things. There are shortcuts under certain
circumstances, which avoid you having to type them.</p>

<p>When a variable is universally quantified in not the formula itself but
the surrounding formula, then you can just use ?x. This is in fact what you
want for rules whcih don't have nested formulae inside the antecentent.</p>

<p>So instead of</p>
<pre>this log:forAll :x, :y.</pre>
<pre>{ :x :parent :y } =&gt;  { :y :child :x }.</pre>

<p>you can write</p>
<pre>{ ?x parent ?y } =&gt;  { ?y :child ?x }.</pre>

<p>which means just the same. We will use this all the time when writing
simple rules. If you need the same variable to appear at several levels, then
you can't use this form.</p>

<p>The other shortcut is that if you have existentially qualified variables
in the scope of the whole document, then you can use _:a and so on. (This is
the same as the ntriples notation)</p>

<p>So instead of writing</p>
<pre>this log:forSome :a, :b.</pre>
<pre>:a :hates :b.   :b :loves :a.</pre>

<p>you could just write</p>
<pre>_:a :hates _:b.   _:b :loves _:a.</pre>

<p></p>

<p>In practice this is very ofetn used in ntriples but in N3, you can
normally use the [] syntax to avoid usiing any variables at all.</p>

<p></p>

<h2><a id="Puctuation1">Shorthand symbols for implies, etc.</a></h2>

<p>When it is used as a predciate (verb) in N3, <code>log:implies</code> and
=&gt; are the same; <code>owl:equivalentTo</code> and = are the same.</p>

<p>So, having gone into a few details of universal and existential
identifiers, what we are left with is a pretty simple rule language, which is
still a fairly straightforward extension of RDF.</p>
<pre>{?x family:parent ?y. ?y family:brother ?z} =&gt; {?x family:uncle ?z}.</pre>

<p></p>

<p>(Always remember the dot after the rule.)</p>

<p>Now let's learn <a href="Processing.html">how to process them</a>.</p>

<p></p>
<hr />

<h2 id="References">References</h2>
<ul>
  <li><a href="Examples.html">Many More Examples</a></li>
  <li><a href="/DesignIssues/Notation3.html">Notation3 - Design Issues
    article</a></li>
  <li>Other rule languages for comparison eg Prolog, RuleML ,  <a
    href="http://herzberg.ca.sandia.gov/jess/docs/52/language.html">Jess</a></li>
</ul>

<p><br />
<br />
</p>
<hr />
Thanks to contributors including Joseph Reagle who added the uncle example to
the original primer.<br />


<p>Tim BL, with his director hat off</p>

<p>$Id$</p>
</body>
</html>
